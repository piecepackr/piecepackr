% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pieceGrob.R
\name{grid.piece}
\alias{grid.piece}
\alias{pmap_piece}
\alias{pieceGrob}
\title{Draw piecepack pieces using grid}
\usage{
pmap_piece(
  .l,
  ...,
  cfg = NULL,
  envir = NULL,
  trans = NULL,
  draw = TRUE,
  name = NULL,
  gp = NULL,
  vp = NULL
)

pieceGrob(
  piece_side = "tile_back",
  suit = NA,
  rank = NA,
  cfg = pp_cfg(),
  x = unit(0.5, "npc"),
  y = unit(0.5, "npc"),
  z = NA,
  angle = 0,
  use_pictureGrob = FALSE,
  width = NA,
  height = NA,
  depth = NA,
  op_scale = 0,
  op_angle = 45,
  default.units = "npc",
  envir = NULL,
  name = NULL,
  gp = NULL,
  vp = NULL
)

grid.piece(
  piece_side = "tile_back",
  suit = NA,
  rank = NA,
  cfg = list(),
  x = unit(0.5, "npc"),
  y = unit(0.5, "npc"),
  z = NA,
  angle = 0,
  use_pictureGrob = FALSE,
  width = NA,
  height = NA,
  depth = NA,
  op_scale = 0,
  op_angle = 45,
  default.units = "npc",
  envir = NULL,
  name = NULL,
  gp = NULL,
  draw = TRUE,
  vp = NULL
)
}
\arguments{
\item{.l}{A list of vectors, such as a data frame. The length of \code{.l}
determines the number of arguments that \code{grid.piece_wrapper}
will be called  with. List names will be used if present.}

\item{...}{Extra arguments to pass to \code{pieceGrob}.}

\item{cfg}{Piecepack configuration list or \code{pp_cfg} object,
a list of \code{pp_cfg} objects,
or a character vector of \code{pp_cfg} objects}

\item{envir}{Environment (or named list) containing configuration list(s).}

\item{trans}{Function to modify \code{.l} before drawing.
Default (\code{NULL}) is to not modify \code{.l}.  \code{op_transform}
can help with using an oblique projection (i.e. \code{op_scale} over 0).}

\item{draw}{A logical value indicating whether graphics output should be produced.}

\item{name}{A character identifier (for grid)}

\item{gp}{An object of class ‘gpar’, typically the output from a call
to the function ‘gpar’.  This is basically a list of
graphical parameter settings.}

\item{vp}{A \code{grid} viewport object (or NULL).}

\item{piece_side}{A string with piece and side separated by a underscore e.g. "coin_face"}

\item{suit}{Number of suit (highest rank starting from 1).
The number above the total number of suits is the neutral "unsuit".
and the next number above that is "no suits".}

\item{rank}{Number of rank (lowest rank starting from 1)}

\item{x}{Where to place piece on x axis of viewport}

\item{y}{Where to place piece on y axis of viewport}

\item{z}{z-coordinate of the piece.  Has no effect if \code{op_scale} is \code{0}.}

\item{angle}{Angle (on xy plane) to draw piece at}

\item{use_pictureGrob}{If \code{TRUE} instead of directly returning the grob first
export to (temporary) svg and then re-import as a \code{grImport2::pictureGrob}.
This is useful if drawing pieces really big or small and don't want
to play with re-configuring fontsizes.}

\item{width}{Width of piece}

\item{height}{Height of piece}

\item{depth}{Depth (thickness) of piece.  Has no effect if \code{op_scale} is \code{0}.}

\item{op_scale}{How much to scale the depth of the piece in the oblique projection
(viewed from the top of the board).
\code{0} (the default) leads to an \dQuote{orthographic} projection,
\code{0.5} is the most common scale used in the \dQuote{cabinet} projection,
 and \code{1.0} is the scale used in the \dQuote{cavalier} projection.}

\item{op_angle}{What is the angle of the oblique projection?  Has no effect if \code{op_scale} is \code{0}.}

\item{default.units}{A string indicating the default units to use if
'x', 'y', 'width', and/or 'height' are only given as numeric vectors.}
}
\value{
A \code{grob} object.  If \code{draw} is \code{TRUE} then as a side effect
        will also draw it to the graphics device.
}
\description{
\code{grid.piece} draws a piecepack pieces onto the graphics device.
\code{pieceGrob} is its \code{grid} \code{grob} counterpart.
\code{pmap_piece} operates on the rows of a data frame
    applying \code{pieceGrob} to each row.
}
\examples{
  if (require("grid")) {
       draw_pp_diagram <- function(cfg=pp_cfg(), op_scale=0) {
           g.p <- function(...) {
               grid.piece(..., op_scale=op_scale, cfg=cfg, default.units="in")
           }
           g.p("tile_back", x=0.5+c(3,1,3,1), y=0.5+c(3,3,1,1))
           g.p("tile_back", x=0.5+3, y=0.5+1, z=1/4+1/8)
           g.p("tile_back", x=0.5+3, y=0.5+1, z=2/4+1/8)
           g.p("die_face", suit=3, rank=5, x=1, y=1, z=1/4+1/4)
           g.p("pawn_face", x=1, y=4, z=1/4+1/2, angle=90)
           g.p("coin_back", x=3, y=4, z=1/4+1/16, angle=180)
           g.p("coin_back", suit=4, x=3, y=4, z=1/4+1/8+1/16, angle=180)
           g.p("coin_back", suit=2, x=3, y=1, z=3/4+1/8, angle=90)
       }

       # default piecepack, orthogonal projection
       draw_pp_diagram(cfg=pp_cfg())

       # custom configuration, orthogonal projection
       grid.newpage()
       dark_colorscheme <- list(suit_color="darkred,black,darkgreen,darkblue,black",
                            invert_colors.suited=TRUE, border_color="black", border_lex=2)
       traditional_ranks <- list(use_suit_as_ace=TRUE, rank_text=",a,2,3,4,5")
       cfg <- c(dark_colorscheme, traditional_ranks)
       draw_pp_diagram(cfg=pp_cfg(cfg))

       # custom configuration, oblique projection
       grid.newpage()
       cfg3d <- list(width.pawn=0.75, height.pawn=0.75, depth.pawn=1,
                          dm_text.pawn="", shape.pawn="convex6", invert_colors.pawn=TRUE,
                          edge_color.coin="tan", edge_color.tile="tan")
       cfg <- pp_cfg(c(cfg, cfg3d))
       draw_pp_diagram(cfg=pp_cfg(cfg), op_scale=0.5)

       # pmap_piece lets you use data frame input
       grid.newpage()
       df_tiles <- data.frame(piece_side="tile_back", x=0.5+c(3,1,3,1), y=0.5+c(3,3,1,1),
                              suit=NA, angle=NA, z=NA, stringsAsFactors=FALSE)
       df_coins <- data.frame(piece_side="coin_back", x=rep(4:1, 4), y=rep(4:1, each=4),
                              suit=1:16\%\%2+rep(c(1,3), each=8),
                              angle=rep(c(180,0), each=8), z=1/4+1/16, stringsAsFactors=FALSE)
       df <- rbind(df_tiles, df_coins)
       pmap_piece(df, cfg=cfg, op_scale=0.5, default.units="in")
  }
}
