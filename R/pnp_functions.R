#' @importFrom grImport2 pictureGrob readPicture grid.symbols
cc_picture <- readPicture(system.file("extdata/by-sa-svg.svg", package="piecepackr"))

is_odd <- function(x) { as.logical(x %% 2) }

LETTER_WIDTH <- 8.5
LETTER_HEIGHT <- 11
A4_WIDTH <- 8.27
A4_HEIGHT <- 11.69
A5W <- 5
A5H <- 7.5

pp_pdf <- function(filename, family, paper) {
    if (paper == "letter") {
        cairo_pdf(filename, onefile=TRUE, width=LETTER_HEIGHT, height=LETTER_WIDTH, family=family)
    } else if (paper == "A4") {
        cairo_pdf(filename, onefile=TRUE, width=A4_HEIGHT, height=A4_WIDTH, family=family)
    } else if (paper == "A5") {
        cairo_pdf(filename, onefile=TRUE, width=A4_HEIGHT/2, height=A4_WIDTH, family=family)
    } else {
        stop(paste("Don't know how to handle paper", paper))
    }
}

#' Make print-and-play piecepack pdf
#'
#' Makes a print-and-play piecepack pdf.
#'
#' @param cfg Piecepack configuration list
#' @param output_filename Filename of PnP output
#' @param size PnP output size (currently either "letter" or "A4")
#' @param pieces Character vector of desired PnP pieces (default everything)
#' @export
make_pnp <- function(cfg=list(), output_filename="piecepack.pdf", size="letter", 
                     pieces=c("piecepack", "matchsticks", "pyramids")) {
    unlink(output_filename)
    directory <- dirname(output_filename)
    dir.create(directory, recursive=TRUE, showWarnings=FALSE)

    cfg <- as_pp_cfg(cfg)
    n_suits <- cfg$n_suits

    if (size == "letter") {
        xl <- inch(LETTER_HEIGHT / 2 - A5W / 2)
        xr <- inch(LETTER_HEIGHT / 2 + A5W / 2)
    } else if (size == "A4") {
        xl <- inch(A4_HEIGHT / 2 - A5W / 2)
        xr <- inch(A4_HEIGHT / 2 + A5W / 2)
    } else { # size == "A5"
        xl <- 0.5
        xr <- 0.5
    }

    pp_pdf(output_filename, cfg$fontfamily, size)

    grid.newpage()
    pushViewport(viewport(x=xl, width=A5W))
    draw_a5_title(cfg$title)
    upViewport()
    if (size == "A5") { grid.newpage() }
    pushViewport(viewport(x=xr, width=A5W))
    draw_a5_blank()
    upViewport()

    if ("piecepack" %in% pieces) {
        for (suit in 1:n_suits) {
            grid.newpage()
            pushViewport(viewport(x=xl, width=A5W))
            draw_a5_piecepack(suit, cfg, front=TRUE)
            upViewport()
            if (size == "A5") { grid.newpage() }
            pushViewport(viewport(x=xr, width=A5W))
            draw_a5_piecepack(suit, cfg, front=FALSE)
            upViewport()
        }
        if (is_odd(n_suits)) {
            grid.newpage()
            pushViewport(viewport(x=xl, width=A5W))
            draw_a5_piecepack(cfg$i_unsuit+1, cfg, front=TRUE)
            upViewport()
            if (size == "A5") { grid.newpage() }
            pushViewport(viewport(x=xr, width=A5W))
            draw_a5_piecepack(cfg$i_unsuit+1, cfg, front=FALSE)
            upViewport()
        }
    }

    #### Fine-tune between pyramids, matchsticks, and misc.
    #### Add misc, cards, dominoes accessories
    if ("matchsticks" %in% pieces) {
        #### What to do if more than 5 suits?
        grid.newpage()
        n <- min(n_suits+2, 5)
        pushViewport(viewport(x=xl, width=A5W))
        draw_a5_matchsticks(1:n, cfg, TRUE)
        upViewport()
        if (size == "A5") { grid.newpage() }
        pushViewport(viewport(x=xr, width=A5W))
        draw_a5_matchsticks(1:n, cfg, FALSE)
        upViewport()
    }
    if ("pyramids" %in% pieces) {
        if (n_suits >= 4) {
            grid.newpage()
            pushViewport(viewport(x=xl, width=A5W))
            draw_a5_pyramids(1:2, cfg, TRUE)
            upViewport()
            if (size == "A5") { grid.newpage() }
            pushViewport(viewport(x=xr, width=A5W))
            draw_a5_pyramids(3:4, cfg, FALSE)
            upViewport()
        }
        if (n_suits > 4) {
            grid.newpage()
            pushViewport(viewport(x=xl, width=A5W))
            draw_a5_pyramids(5:6, cfg, TRUE)
            upViewport()
            if (size == "A5") { grid.newpage() }
            pushViewport(viewport(x=xr, width=A5W))
            draw_a5_blank()
            upViewport()
        }
    }
    invisible(dev.off())
}

a5_vp <- viewport(width=unit(A5W, "in"), height=unit(A5H, "in"))

draw_a5_title <- function(title="Piecepack collection") {
    pushViewport(viewport(width=inch(A5W), height=inch(A5H)))
    grid.rect(gp=gpar(color="brown"))
    header_height <- 1.5
    y_header <- A5H - header_height/2

    # title
    gp_title <- gpar(fontsize=15, fontfamily="sans", fontface="bold")
    grid.text(title, y=0.97, just="center", gp=gp_title)

    # CC images
    width_image = 0.14
    x <- c(0.02 + 0.5*width_image, 0.98-0.5*width_image)
    grid.symbols(cc_picture, x=x, y=0.9, size=inch(0.9))

    # text
    license <- paste(c("This print-and-play layout was generated by piecepackr.",
        "This work is licensed under a CC BY-SA 4.0 license:",
        "https://creativecommons.org/licenses/by-sa/4.0"
                ), collapse="\n")
    gp <- gpar(fontsize=9, fontfamily="sans")
    grid.text(license, x=0.5, y=0.91, just="center", gp=gp)


    credits <- c('The piecepack was invented by James "Kyle" Droscha.',
                 'Pawn saucers were invented by Karol M. Boyle.',
                 'Piecepack pyramids were invented by Tim Schutz.',
                 'Piecepack matchsticks were invented by Dan Burkey.',
                 'piecepackr was written by Trevor L Davis.')
    credits <- paste("\u25cf", credits, collapse="\n")
    gp_header <- gpar(fontsize=12, fontfamily="sans", fontface="bold")
    grid.text("Credits", x=0.1, y=0.75, just="left", gp=gp_header)
    grid.text(credits, x=0.1, y=0.7, just=c(0,1), gp=gp)

    upViewport()
}

draw_a5_blank <- function() {
    grid.rect(gp=gpar(color="brown"), vp=a5_vp)
    grid.text("Intentionally left blank", vp=a5_vp)
}


draw_a5_matchsticks <- function(suits=1:5, cfg=pp_cfg(), front=TRUE) {

    n_suits <- length(suits)
    y1t <- A5H - 0.5* MATCHSTICK_HEIGHTS[1]
    y1b <- A5H - 1.5* MATCHSTICK_HEIGHTS[1]
    x1s <- (0.5 + 0:(2*n_suits-1)) * MATCHSTICK_WIDTHS[1]
    xs <-  (0.5 + 0:(4*n_suits-1)) * MATCHSTICK_WIDTHS[2]
    y2  <- y1b - 0.5*MATCHSTICK_HEIGHTS[1] - 0.5*MATCHSTICK_HEIGHTS[2]
    y3  <- y2  - 0.5*MATCHSTICK_HEIGHTS[2] - 0.5*MATCHSTICK_HEIGHTS[3]
    y5  <- y3  - 0.5*MATCHSTICK_HEIGHTS[3] - 0.5*MATCHSTICK_HEIGHTS[5]
    y6  <- y5  - 0.5*MATCHSTICK_HEIGHTS[5] - 0.5*MATCHSTICK_HEIGHTS[6]
    y4s <- A5H - (0.5 + 0:3)*MATCHSTICK_HEIGHTS[4]
    x4s <- 4*n_suits * MATCHSTICK_WIDTHS[2] + (0.5 + 0:(n_suits-1)) * MATCHSTICK_WIDTHS[6]

    x = c(rep(x1s,each=2), rep(xs, 4), rep(x4s, each=4))
    y = c(rep(c(y1t, y1b), 2*n_suits), rep(c(y2, y3, y5, y6), each=4*n_suits), rep(c(y4s), n_suits))
    suit = rep(rep(suits, each=4), 6)
    rank = rep(c(1:3,5:6,4), each=4*n_suits)
    if (front) {
        piece_side = "matchstick_face"
    } else {
        x <- A5W - x
        piece_side = "matchstick_back"

    }
    df <- tibble::tibble(piece_side, x, y, suit, rank)

    grid.rect(gp=gpar(color="brown"), vp=a5_vp)
    pmap_piece(df, cfg=cfg, default.units="inches", vp=a5_vp)
}

draw_a5_piecepack <- function(suit, cfg=pp_cfg(), front=TRUE) {
    xtl <- 1.5 * TILE_WIDTH
    xtr <- 0.5 * TILE_WIDTH
    ytb <- 0.5 * TILE_WIDTH
    ytm <- 1.5 * TILE_WIDTH
    ytt <- 2.5 * TILE_WIDTH
    xc <-A5W - 0.25 * TILE_WIDTH
    # ycs <- 0.50 + seq(0, 2.50, 0.50) * TILE_WIDTH
    ycs <- (0.50 + seq(0, 5)) * 0.8
    # xdl <- A5W - 4 * DIE_WIDTH
    # xdm <- A5W - 6 * DIE_WIDTH
    xdr <- A5W - 8 * DIE_WIDTH
    yd <- A5H - 1.5 * DIE_WIDTH
    xp <- DIE_LAYOUT_WIDTH + 0.5 * cfg$get_pp_height("pawn_layout")
    yp <- A5H - 0.5 * PAWN_WIDTH
    xb <- DIE_LAYOUT_WIDTH + 0.5 * BELT_WIDTH
    yb <- A5H - PAWN_WIDTH - 0.5 * BELT_HEIGHT
    xsl <- A5W - 0.75 * TILE_WIDTH
    xsr <- A5W - 0.25 * TILE_WIDTH
    ysb <- 2.75 * TILE_WIDTH 
    x <- c(rep(c(xtl, xtr), 3), rep(xc, 6), xdr, xp, xb, xsr)
    y <- c(rep(c(ytt, ytm, ytb), each=2), ycs, yd, yp, yb, ysb)
    if (front) {
        x <- A5W - x
        piece_side <- c(rep("tile_face", 6), rep("coin_back", 6),
                            rep("die_layoutRF", 1), "pawn_layout", "belt_face", "saucer_face")
        suits <- c(rep(suit, 16))
        rank <- c(1:6, rep(NA, 6), rep(NA, 4))
        angle = c(rep(0, 13), 90, rep(0, 2))
    } else {
        piece_side <- c(rep("tile_back", 6), rep("coin_face", 6),
                            rep("die_layoutLF", 1), "pawn_layout", "belt_face", "saucer_back")
        suits <- c(rep(NA, 12), rep(suit, 3), cfg$i_unsuit)
        rank <- c(rep(NA, 6), 1:6, rep(NA, 4))
        angle = c(rep(0, 13), 90, rep(0, 2))
    }
    df <- tibble::tibble(piece_side, x, y, suit=suits, rank, angle)

    grid.rect(gp=gpar(color="brown"), vp=a5_vp)
    pmap_piece(df, cfg=cfg, default.units="inches", vp=a5_vp)
}

draw_a5_pyramids <- function(suit=1:2, cfg=pp_cfg(), front=TRUE) {
    n_ranks <- cfg$n_ranks
    n_suits <- cfg$n_suits
    y_up <- rep(cumsum(PYRAMID_LAYOUT_HEIGHTS) - 0.5*PYRAMID_LAYOUT_HEIGHTS, each=2)
    x_up <- rep(c(0.5, 1.5), 7)*rep(PYRAMID_LAYOUT_WIDTHS, each=2)
    x <- c(x_up[1:8], A5W - x_up[9:12]- rep(c(0.75,1),each=2))
    p5h <- PYRAMID_LAYOUT_HEIGHTS[5]; p6h <- PYRAMID_LAYOUT_HEIGHTS[6]
    y <- c(y_up[1:8], rep(c(p6h+0.5*p5h, 0.5*p6h), each=2))
    piece_side <- "pyramid_layout"
    suit <- rep(suit, 6, length.out=12)
    rank <- rep(1:6, each=2)
    angle <- c(rep(c(180, 0), 4), rep(c(0, 180), 2))
    df <- tibble::tibble(piece_side, x, y, suit, rank, angle)

    grid.rect(gp=gpar(color="brown"), vp=a5_vp)
    pmap_piece(df, cfg=cfg, default.units="inches", vp=a5_vp)
}

#### Separate out add_metadata and remove
# make_collection <- function(output_filename, input_filenames, size="letter", metadata=list()) {
#     unlink(output_filename)
#     directory <- dirname(output_filename)
#     dir.create(directory, recursive=TRUE, showWarnings=FALSE)
# 
#     # add bookmarks
#     pm_filename <- tempfile(fileext=".txt")
#     make_pdfmark_txt(pm_filename, input_filenames)
# 
#     temp_pdf <- tempfile(fileext=".pdf")
#     cmd <- find_gs()
#     args <- c("-q", "-o", shQuote(temp_pdf), "-sDEVICE=pdfwrite", pm_filename, shQuote(input_filenames))
#     system2(cmd, args)
# 
#     #### What to do with metadata
#     pm_filename <- tempfile(fileext=".txt")
#     make_pdfmark_metadata(pm_filename, metadata$title, metadata$author, metadata$subject, metadata$keywords)
#     args <- c("-q", "-o", shQuote(output_filename), "-sDEVICE=pdfwrite", pm_filename, shQuote(temp_pdf))
#     system2(cmd, args)
# 
# }
# 
# make_pdfmark_txt <- function(pm_filename, input_filenames) {
#     deck_filenames <- input_filenames[-1]
#     n_sets <- length(deck_filenames) 
# 
#     n_preview <- ceiling(n_sets / 6)
#     if (is_odd(n_preview))
#         n_preview <- n_preview + 1
#     txt <- "[/Page 1 /View [/XYZ null null null] /Title (Piecepack Sets Preview) /OUT pdfmark"
#     next_page <- n_preview + 1
#     for(ii in 1:n_sets) {
#         new_txt <- sprintf("[/Page %s /View [/XYZ null null null] /Title (Piecepack Set #%s) /OUT pdfmark", next_page, ii)
#         txt <- append(txt, new_txt)
#         next_page <- next_page + get_n_pages(deck_filenames[ii])
#     }
#     writeLines(txt, pm_filename)
# }
# 
# make_pdfmark_metadata <- function(pm_filename, title="Piecepack collection", author="", subject="", keywords="piecepack") {
#     txt <- paste0("[ /Title (", title, ")\n /Author (", author, ")\n /Subject (", 
#                 subject, ")\n /Keywords (", keywords, ")\n /DOCINFO pdfmark")
# 
#     writeLines(txt, pm_filename)
# }
